<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Particle Background</title>
    <style>
      :root {
        color-scheme: dark;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        overflow: hidden;
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Helvetica,
          Arial,
          "Apple Color Emoji",
          "Segoe UI Emoji";
        background: radial-gradient(1200px 600px at 10% 10%, #1f2b72 0%, rgba(0, 0, 0, 0) 60%),
          radial-gradient(900px 500px at 90% 20%, #7c3aed 0%, rgba(0, 0, 0, 0) 55%),
          radial-gradient(900px 700px at 50% 100%, #0b1220 0%, #05060a 70%);
      }

      canvas#bg {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
      }

      .overlay {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        pointer-events: none;
      }

      .card {
        pointer-events: auto;
        padding: 18px 22px;
        border-radius: 16px;
        background: rgba(10, 12, 20, 0.55);
        border: 1px solid rgba(255, 255, 255, 0.12);
        box-shadow: 0 16px 48px rgba(0, 0, 0, 0.45);
        backdrop-filter: blur(10px);
        max-width: 560px;
        margin: 16px;
      }

      .title {
        margin: 0 0 8px;
        font-size: 20px;
        letter-spacing: 0.2px;
      }

      .desc {
        margin: 0;
        opacity: 0.85;
        line-height: 1.5;
      }

      .hint {
        margin: 10px 0 0;
        font-size: 12px;
        opacity: 0.7;
      }
    </style>
  </head>
  <body>
    <canvas id="bg" aria-hidden="true"></canvas>
    <div class="overlay">
      <div class="card">
        <h1 class="title">Three.js 雪花粒子背景</h1>
        <p class="desc">雪花在背景中持续下落并轻微飘动，位置不断变化。</p>
        <p class="hint">鼠标移动有轻微视差；窗口 resize 自适应；减少动态偏好会降速。</p>
      </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script>
      const canvas = document.getElementById("bg");
      const prefersReducedMotion = window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches ?? false;

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 200);
      camera.position.set(0, 0, 22);

      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true, powerPreference: "high-performance" });
      renderer.setClearColor(0x000000, 0);

      const PARTICLE_COUNT = 1200;
      const FIELD_WIDTH = 48;
      const FIELD_HEIGHT = 34;
      const FIELD_DEPTH = 32;

      function createSnowflakeTexture() {
        const size = 64;
        const c = document.createElement("canvas");
        c.width = size;
        c.height = size;
        const ctx = c.getContext("2d");
        const g = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
        g.addColorStop(0, "rgba(255,255,255,1)");
        g.addColorStop(0.35, "rgba(255,255,255,0.55)");
        g.addColorStop(0.65, "rgba(255,255,255,0.18)");
        g.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, size, size);
        const tex = new THREE.CanvasTexture(c);
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.generateMipmaps = false;
        return tex;
      }

      const positions = new Float32Array(PARTICLE_COUNT * 3);
      const speeds = new Float32Array(PARTICLE_COUNT);
      const scales = new Float32Array(PARTICLE_COUNT);
      const seeds = new Float32Array(PARTICLE_COUNT);

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        positions[i3 + 0] = (Math.random() - 0.5) * FIELD_WIDTH;
        positions[i3 + 1] = (Math.random() - 0.5) * FIELD_HEIGHT;
        positions[i3 + 2] = (Math.random() - 0.5) * FIELD_DEPTH;
        speeds[i] = 0.35 + Math.random() * 0.55;
        scales[i] = 0.55 + Math.random() * 0.45;
        seeds[i] = Math.random() * 1000;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute("aScale", new THREE.BufferAttribute(scales, 1));
      geometry.setAttribute("aSeed", new THREE.BufferAttribute(seeds, 1));

      const material = new THREE.ShaderMaterial({
        transparent: true,
        depthWrite: false,
        blending: THREE.NormalBlending,
        uniforms: {
          uTime: { value: 0 },
          uPixelRatio: { value: 1 },
          uBaseSize: { value: 10.0 },
          uTexture: { value: createSnowflakeTexture() },
        },
        vertexShader: `
          uniform float uTime;
          uniform float uPixelRatio;
          uniform float uBaseSize;
          attribute float aScale;
          attribute float aSeed;
          varying float vTwinkle;
          void main() {
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            float perspective = 28.0 / max(6.0, -mvPosition.z);
            gl_PointSize = clamp(uBaseSize * aScale * uPixelRatio * perspective, 1.0, 18.0);
            vTwinkle = 0.55 + 0.45 * sin(uTime * 1.6 + aSeed);
          }
        `,
        fragmentShader: `
          uniform sampler2D uTexture;
          varying float vTwinkle;
          void main() {
            vec4 tex = texture2D(uTexture, gl_PointCoord);
            float alpha = tex.a * vTwinkle;
            vec3 color = vec3(0.93, 0.97, 1.0);
            gl_FragColor = vec4(color, alpha);
          }
        `,
      });

      const points = new THREE.Points(geometry, material);
      scene.add(points);

      const mouse = { x: 0, y: 0 };
      window.addEventListener(
        "mousemove",
        (e) => {
          const nx = (e.clientX / window.innerWidth) * 2 - 1;
          const ny = (e.clientY / window.innerHeight) * 2 - 1;
          mouse.x = nx;
          mouse.y = ny;
        },
        { passive: true },
      );

      function resize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h, false);
        const pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
        renderer.setPixelRatio(pixelRatio);
        material.uniforms.uPixelRatio.value = pixelRatio;
      }
      window.addEventListener("resize", resize, { passive: true });
      resize();

      const clock = new THREE.Clock();
      let raf = 0;

      function tick() {
        raf = requestAnimationFrame(tick);

        const dt = Math.min(clock.getDelta(), 0.05);
        const speedMultiplier = prefersReducedMotion ? 0.35 : 1;
        const t = clock.elapsedTime;

        material.uniforms.uTime.value = t;

        camera.position.x += (mouse.x * 1.2 - camera.position.x) * 0.05;
        camera.position.y += (mouse.y * 0.6 - camera.position.y) * 0.05;
        camera.lookAt(0, 0, 0);

        const halfW = FIELD_WIDTH / 2;
        const halfH = FIELD_HEIGHT / 2;
        const halfD = FIELD_DEPTH / 2;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const i3 = i * 3;
          const driftX = Math.sin(t * 0.25 + seeds[i]) * 0.06;
          const driftZ = Math.cos(t * 0.2 + seeds[i]) * 0.02;
          positions[i3 + 0] += driftX * dt * 60 * speedMultiplier;
          positions[i3 + 2] += driftZ * dt * 60 * speedMultiplier;
          positions[i3 + 1] -= speeds[i] * dt * 2.2 * speedMultiplier;

          if (positions[i3 + 1] < -halfH) {
            positions[i3 + 1] = halfH + Math.random() * 2;
            positions[i3 + 0] += (Math.random() - 0.5) * 2.5;
            positions[i3 + 2] += (Math.random() - 0.5) * 1.5;
          }

          if (positions[i3 + 0] > halfW) positions[i3 + 0] = -halfW;
          if (positions[i3 + 0] < -halfW) positions[i3 + 0] = halfW;
          if (positions[i3 + 2] > halfD) positions[i3 + 2] = -halfD;
          if (positions[i3 + 2] < -halfD) positions[i3 + 2] = halfD;
        }

        geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
      }

      function stop() {
        if (raf) cancelAnimationFrame(raf);
        raf = 0;
      }

      document.addEventListener(
        "visibilitychange",
        () => {
          if (document.hidden) stop();
          else {
            clock.getDelta();
            tick();
          }
        },
        { passive: true },
      );

      tick();
    </script>
  </body>
</html>
